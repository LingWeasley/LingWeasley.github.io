<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.8.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.8.0" type="image/png" sizes="32x32"><meta name="description" content="3.1栈（stack）                           3.1.1栈的基本概念                           1.栈的定义        栈是特殊的线性表：只允许在一端进行插入或删- 除操作， 其逻辑结构与普通线性表相同；">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构-栈和队列">
<meta property="og:url" content="http://example.com/2019/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/index.html">
<meta property="og:site_name" content="漏勺的加油站">
<meta property="og:description" content="3.1栈（stack）                           3.1.1栈的基本概念                           1.栈的定义        栈是特殊的线性表：只允许在一端进行插入或删- 除操作， 其逻辑结构与普通线性表相同；">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-05-15T00:00:00.000Z">
<meta property="article:modified_time" content="2023-06-16T13:13:30.189Z">
<meta property="article:author" content="小勺">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary"><title>数据结构-栈和队列 | 漏勺的加油站</title><link ref="canonical" href="http://example.com/2019/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.8.0"><link rel="stylesheet" href="css/custom.css"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  assistSearch: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":false},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"复制","copySuccess":"复制成功","copyError":"复制失败"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 6.0.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">首页</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">归档</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/categories/"><span class="header-nav-menu-item__icon"><i class="fas fa-layer-group"></i></span><span class="header-nav-menu-item__text">分类</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/tags/"><span class="header-nav-menu-item__icon"><i class="fas fa-tags"></i></span><span class="header-nav-menu-item__text">标签</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content" id="content"><!-- Just used to judge whether it is an article page--><div id="is-post"></div><div class="post"><header class="post-header"><h1 class="post-title">数据结构-栈和队列</h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">发表于</span><span class="post-meta-item__value">2019-05-15</span></span><span class="post-meta-item post-meta-item--updatetime"><span class="post-meta-item__icon"><i class="far fa-calendar-check"></i></span><span class="post-meta-item__info">更新于</span><span class="post-meta-item__value">2023-06-16</span></span></div></header><div class="post-body">
        <h1 id="3-1栈（stack）"   >
          <a href="#3-1栈（stack）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1栈（stack）" class="headerlink" title="3.1栈（stack）"></a>3.1栈（stack）</h1>
      
        <h2 id="3-1-1栈的基本概念"   >
          <a href="#3-1-1栈的基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-1栈的基本概念" class="headerlink" title="3.1.1栈的基本概念"></a>3.1.1栈的基本概念</h2>
      
        <h3 id="1-栈的定义"   >
          <a href="#1-栈的定义" class="heading-link"><i class="fas fa-link"></i></a><a href="#1-栈的定义" class="headerlink" title="1.栈的定义"></a>1.栈的定义</h3>
      <ul>
<li>栈是特殊的线性表：只允许在一端进行插入或删- 除操作， 其逻辑结构与普通线性表相同； <span id="more"></span></li>
<li>栈顶（Top）：允许进行插入和删除的一端 （最上面的为栈顶元素）；</li>
<li>栈底（Bottom）：固定的，不允许进行插入和删除的一端 （最下面的为栈底元素）；</li>
<li>空栈：不含任何元素的空表；</li>
<li>特点：后进先出（后进栈的元素先出栈）；</li>
<li>缺点：栈的大小不可变，解决方法——共享栈；
        <h3 id="2-栈的基本操作"   >
          <a href="#2-栈的基本操作" class="heading-link"><i class="fas fa-link"></i></a><a href="#2-栈的基本操作" class="headerlink" title="2.栈的基本操作"></a>2.栈的基本操作</h3>
      </li>
</ul>
<ol>
<li>“创建&amp;销毁”</li>
</ol>
<ul>
<li>InitStack(&amp;S) 初始化栈：构造一个空栈S，分配内存空间；</li>
<li>DestroyStack(&amp;S) 销毁栈：销毁并释放栈S所占用的内存空间；</li>
</ul>
<ol start="2">
<li>“增&amp;删”</li>
</ol>
<ul>
<li>Push(&amp;S, x) 进栈：若栈S未满，则将x加入使其成为新栈顶；</li>
<li>Pop(&amp;S, &amp;x) 出栈：若栈S非空，则弹出（删除）栈顶元素，并用x返回；<br>“查&amp;其他”</li>
<li>GetTop(S, &amp;x) 读取栈顶元素：若栈S非空，则用x-返回栈顶元素；（栈的使用场景大多只访问栈顶元素）；</li>
<li>StackEmpty(S) 判空： 断一个栈S是否为空，若S为空，则返回true,否则返回false；
        <h3 id="3-1-2-栈的顺序存储"   >
          <a href="#3-1-2-栈的顺序存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-2-栈的顺序存储" class="headerlink" title="3.1.2 栈的顺序存储"></a>3.1.2 栈的顺序存储</h3>
      </li>
</ul>
<ol>
<li><p>顺序栈的定义</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶元素</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqStack S;       <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">                     <span class="comment">//连续的存储空间大小为 MaxSize*sizeof(ElemType)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>顺序栈的基本操作</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top;                      <span class="comment">//栈顶元素</span></span><br><span class="line">&#125;SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top = <span class="number">-1</span>;                   <span class="comment">//初始化栈顶指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)      <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span>                 <span class="comment">//栈不空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新元素进栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == MaxSize - <span class="number">1</span>)        <span class="comment">//栈满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    S.top = S.top + <span class="number">1</span>;    <span class="comment">//指针先加1</span></span><br><span class="line">    S.data[S.top] = x;    <span class="comment">//新元素入栈</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    S.data[++S.top] = x;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//出栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;x, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)          <span class="comment">//栈空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    x = S.data[S.top];       <span class="comment">//先出栈</span></span><br><span class="line">    S.top = S.top - <span class="number">1</span>;       <span class="comment">//栈顶指针减1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    x = S.data[S.top--];</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只是逻辑上的删除，数据依然残留在内存里</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读栈顶元素</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTop</span><span class="params">(SqStack S, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    x = S.data[S.top];      <span class="comment">//x记录栈顶元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">testStack</span><span class="params">()</span></span>&#123;</span><br><span class="line">    SqStack S;       <span class="comment">//声明一个顺序栈(分配空间)</span></span><br><span class="line">    <span class="built_in">InitStack</span>(S);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>
<p>**注意:也可以初始化时定义 S.top &#x3D; 0 ：top指针指向下一个可以插入元素的位置(栈顶元素的后一个位置)；</p>
<ul>
<li>进栈操作 ：栈不满时，栈顶指针先加1，再送值到栈顶元素。S.data[S.top++] &#x3D; x;</li>
<li>出栈操作：栈非空时，先取栈顶元素值，再将栈顶指针减1。&#96;x &#x3D; S.data[–S.top];</li>
<li>栈空条件：S.top&#x3D;&#x3D;-1</li>
<li>栈满条件：S.top&#x3D;&#x3D;MaxSize-1</li>
<li>栈长：S.top+1</li>
</ul>
<ol start="3">
<li>共享栈</li>
</ol>
<p>**定义：利用栈底位置相对不变的特性，可以让两个顺序栈共享一个一维数组空间，将两个栈的栈底 分别设置在共享空间的两端，两个栈顶向共享空间的中间延伸。</p>
<ul>
<li>存取数据的时间复杂度均为O（1）<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10         <span class="comment">//定义栈中元素的最大个数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];       <span class="comment">//静态数组存放栈中元素</span></span><br><span class="line">    <span class="type">int</span> top0;                     <span class="comment">//0号栈栈顶指针</span></span><br><span class="line">    <span class="type">int</span> top1;                     <span class="comment">//1号栈栈顶指针</span></span><br><span class="line">&#125;ShStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitSqStack</span><span class="params">(ShStack &amp;S)</span></span>&#123;</span><br><span class="line">    S.top0 = <span class="number">-1</span>;        <span class="comment">//初始化栈顶指针</span></span><br><span class="line">    S.top1 = MaxSize;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
栈满条件：top1-top0&#x3D;1</li>
</ul>

        <h3 id="3-1-3栈的链式存储"   >
          <a href="#3-1-3栈的链式存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-1-3栈的链式存储" class="headerlink" title="3.1.3栈的链式存储"></a>3.1.3栈的链式存储</h3>
      <ol>
<li>定义：采用链式存储的栈称为链栈。</li>
<li>优点：链栈的优点是便于多个栈共享存储空间和提高其效率，且不存在栈满上溢的情况。</li>
<li>特点：</li>
</ol>
<ul>
<li>进栈和出栈都只能在栈顶一端进行(链头作为栈顶)</li>
<li>链表的头部作为栈顶，意味着：</li>
</ul>
<ol>
<li>在实现数据”入栈”操作时，需要将数据从链表的头部插入；</li>
<li>在实现数据”出栈”操作时，需要删除链表头部的首元节点；<br>因此，链栈实际上就是一个只能采用头插法插入或删除数据的链表;<br>栈的链式存储结构可描述为：<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Linknode</span>&#123;</span><br><span class="line">    ElemType data;              <span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Linknode</span> *next;      <span class="comment">//指针域</span></span><br><span class="line">&#125;*LiStack;                      <span class="comment">//栈类型的定义</span></span><br></pre></td></tr></table></div></figure></li>
<li>栈的基本操作：</li>
</ol>
<ul>
<li>初始化</li>
<li>进栈</li>
<li>出栈</li>
<li>获取栈顶元素</li>
<li>判空、判满<br>带头结点的链栈基本操作：<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Linknode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    Linknode *next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linknode *Node;   <span class="comment">//结点结构体指针变量</span></span><br><span class="line"><span class="keyword">typedef</span> Node List;        <span class="comment">//结点结构体头指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1. 初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitStack</span><span class="params">(LiStack &amp;L)</span></span>&#123;   <span class="comment">//L为头指针</span></span><br><span class="line">    L = <span class="keyword">new</span> Linknode; </span><br><span class="line">    L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LiStack &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 进栈(：链栈基本上不会出现栈满的情况)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Linknode s;          <span class="comment">//创建存储新元素的结点</span></span><br><span class="line">    s = <span class="keyword">new</span> Linknode;</span><br><span class="line">    s-&gt;data = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//头插法</span></span><br><span class="line">    s-&gt;next = L-&gt;next;</span><br><span class="line">    L-&gt;next = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">popStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    Linknode s;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;next == <span class="literal">NULL</span>) <span class="comment">//栈空不能出栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">    s = L-&gt;next;</span><br><span class="line">    x = s-&gt;data;</span><br><span class="line">    L-&gt;next = L-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">delete</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p>不带头结点的链栈基本操作：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Linknode</span>&#123;</span><br><span class="line">    <span class="type">int</span> data;             <span class="comment">//数据域</span></span><br><span class="line">    Linknode *next;       <span class="comment">//指针域</span></span><br><span class="line">&#125;Linknode,*LiStack;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Linknode *Node;   <span class="comment">//结点结构体指针变量</span></span><br><span class="line"><span class="keyword">typedef</span> Node List;        <span class="comment">//结点结构体头指针变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.初始化 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">initStack</span><span class="params">(LiStack &amp;L)</span></span>&#123;</span><br><span class="line">    L=<span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.判栈空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isEmpty</span><span class="params">(LiStack &amp;L)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(L == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        teturn <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.进栈</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    Linknode s;          <span class="comment">//创建存储新元素的结点</span></span><br><span class="line">    s = <span class="keyword">new</span> Linknode;</span><br><span class="line"></span><br><span class="line">    s-&gt;next = L;</span><br><span class="line">    L = s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.出栈</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">popStack</span><span class="params">(LiStack &amp;L, <span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    Linknode s; </span><br><span class="line">    <span class="keyword">if</span>(L = <span class="literal">NULL</span>)     <span class="comment">//栈空不出栈</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    s = L;</span><br><span class="line">    x = s-&gt;data;</span><br><span class="line">    L = L-&gt;next;</span><br><span class="line">    <span class="built_in">delete</span>(s);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="3-2队列（Queue）"   >
          <a href="#3-2队列（Queue）" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2队列（Queue）" class="headerlink" title="3.2队列（Queue）"></a>3.2队列（Queue）</h2>
      
        <h3 id="3-2-1队列的基本概念"   >
          <a href="#3-2-1队列的基本概念" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-1队列的基本概念" class="headerlink" title="3.2.1队列的基本概念"></a>3.2.1队列的基本概念</h3>
      <ol>
<li>定义：队列（Queue）简称队，是一种操作受限的线性表，只允许在表的一端进行插入，而在表的另一端进行删除。</li>
<li>特点</li>
</ol>
<ul>
<li>队列是操作受限的线性表，只允许在一端进行插入 (入队)，另一端进行删除 (出队)</li>
<li>操作特性：先进先出 FIFO</li>
<li>队头：允许删除的一端</li>
<li>队尾：允许插入的一端</li>
<li>空队列：不含任何元素的空表</li>
</ul>
<ol start="3">
<li>队列的基本操作<br>“创建&amp;销毁”</li>
</ol>
<ul>
<li>InitQueue(&amp;Q): 初始化队列，构造一个空列表Q</li>
<li>DestroyQueue(&amp;Q): 销毁队列，并释放队列Q所占用的内存空间<br>“增&amp;删”</li>
<li>EnQueue(&amp;Q, x): 入队，若队列Q未满，将x加入，使之成为新的队尾</li>
<li>DeQueue(&amp;Q, &amp;x): 出队，若队列Q非空，删除队头元素，并用x返回<br>“查&amp;其他”</li>
<li>GetHead(Q,&amp;x): 读队头元素，若队列Q非空，则将队头元素赋值给x</li>
<li>QueueEmpty(Q): 判队列空，若队列Q为空，则返回
        <h3 id="3-2-2队列的顺序存储结构"   >
          <a href="#3-2-2队列的顺序存储结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-2队列的顺序存储结构" class="headerlink" title="3.2.2队列的顺序存储结构"></a>3.2.2队列的顺序存储结构</h3>
      </li>
<li>队头指针：指向队头元素</li>
<li>队尾指针：指向队尾元素的下一个位置</li>
</ul>
<p>1.队列存储的基本操作</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//队列的顺序存储类型</span></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     <span class="comment">//定义队列中元素的最大个数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];   <span class="comment">//用静态数组存放队列元素</span></span><br><span class="line">                              <span class="comment">//连续的存储空间，大小为——MaxSize*sizeof(ElemType)</span></span><br><span class="line">    <span class="type">int</span> front, rear;          <span class="comment">//队头指针和队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，队头、队尾指针指向0</span></span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> test&#123;</span><br><span class="line">    SqQueue Q;                <span class="comment">//声明一个队列</span></span><br><span class="line">    <span class="built_in">InitQueue</span>(Q);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue <span class="number">0</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)    <span class="comment">//判空条件后</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>循环队列<br>定义：将循环队列臆造为一个环状的空间，即把存储队列元素的表从逻辑上视为一个环，称为循环队列。<br>基本操作：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a%b == a除以b的余数</span><br><span class="line"></span><br><span class="line">初始：Q.front = Q.rear = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">队首指针进<span class="number">1</span>：Q.front = (Q.front + <span class="number">1</span>) % MaxSize</span><br><span class="line"></span><br><span class="line">队尾指针进<span class="number">1</span>：Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize —— 队尾指针后移，当移到最后一个后，下次移动会到第一个位置</span><br><span class="line"></span><br><span class="line">队列长度：(Q.rear + MaxSize - Q.front) % MaxSize</span><br></pre></td></tr></table></div></figure>

<p>区分队空还是队满的情况：<br>方案一: 牺牲一个单元来区分队空和队满<br>队尾指针的再下一个位置就是队头，即 (Q.rear+1)%MaxSize &#x3D;&#x3D; Q.front</p>
<ul>
<li>循环队列——入队：只能从队尾插入（判满使用方案一） <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MaxSize == Q.front)        <span class="comment">//队满</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    Q.data[Q.rear] = x;                      <span class="comment">//将x插入队尾</span></span><br><span class="line">    Q.rear = (Q.rear + <span class="number">1</span>) % MaxSize;         <span class="comment">//队尾指针加1取模</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p>循环队列——出队：只能让队头元素出队</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队，删除一个队头元素，用x返回</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)              <span class="comment">//队空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    Q.front = (Q.front + <span class="number">1</span>) % MaxSize; <span class="comment">//队头指针后移动</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li>循环队列——获得队头元素<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetHead</span><span class="params">(SqQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear == Q.front)              <span class="comment">//队空报错</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;  </span><br><span class="line"></span><br><span class="line">    x = Q.data[Q.front];</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
方案二: 不牺牲存储空间，设置size<br>定义一个变量 size用于记录队列此时记录了几个数据元素，初始化 size &#x3D; 0，进队成功 size++，出队成功size–，根据size的值判断队满与队空<br>队满条件：size &#x3D;&#x3D; MaxSize</li>
</ul>
<p>队空条件：size &#x3D;&#x3D; 0</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];   </span><br><span class="line">    <span class="type">int</span> front, rear;        </span><br><span class="line">    <span class="type">int</span> size;               <span class="comment">//队列当前长度</span></span><br><span class="line">&#125;SqQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    Q.rear = Q.front = <span class="number">0</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>方案三: 不牺牲存储空间，设置tag<br>定义一个变量 tag，tag &#x3D; 0 –最近进行的是删除操作；tag &#x3D; 1 –最近进行的是插入操作；</p>
<p>每次删除操作成功时，都令tag &#x3D; 0；只有删除操作，才可能导致队空；<br>每次插入操作成功时，都令tag &#x3D; 1；只有插入操作，才可能导致队满；<br>队满条件：Q.front &#x3D;&#x3D; Q.rear &amp;&amp; tag &#x3D;&#x3D; 1</p>
<p>队空条件：Q.front &#x3D;&#x3D; Q.rear &amp;&amp; tag &#x3D;&#x3D; 0</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="keyword">define</span> MaxSize 10;     </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    ElemType data[MaxSize];   </span><br><span class="line">    <span class="type">int</span> front, rear;        </span><br><span class="line">    <span class="type">int</span> tag;               <span class="comment">//最近进行的是删除or插入</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-2-3队列的链式存储结构"   >
          <a href="#3-2-3队列的链式存储结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-3队列的链式存储结构" class="headerlink" title="3.2.3队列的链式存储结构"></a>3.2.3队列的链式存储结构</h3>
      <ol>
<li><p>定义：队列的链式表示称为链队列，它实际上是一个同时带有队头指针和队尾指针的单链表。<br>链队列：用链表表示的队列，是限制仅在表头删除和表尾插入的单链表。<br>队列的链式存储类型可描述为:</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">LinkNode</span>&#123;      <span class="comment">//链式队列结点</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkNode</span> *next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;               <span class="comment">//链式队列</span></span><br><span class="line">    LinkNode *front, *rear;   <span class="comment">//队列的队头和队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>链式队列的基本操作——带头结点</p>
</li>
</ol>
<ul>
<li>初始化 &amp; 判空 <figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitQueue</span><span class="params">(LinkQueue &amp;Q)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化时，front、rear都指向头结点</span></span><br><span class="line">    Q.front = Q.rear = (LinkNode*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode));</span><br><span class="line">    Q.front -&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue Q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)     <span class="comment">//也可用 Q.front -&gt; next == NULL</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>
<p>入队操作</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队 (表尾进行)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode)); <span class="comment">//申请一个新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;     <span class="comment">//s作为最后一个结点，指针域指向NULL</span></span><br><span class="line">    Q.rear-&gt;next = s;   <span class="comment">//新结点插入到当前的rear之后</span></span><br><span class="line">    Q.rear = s;         <span class="comment">//表尾指针指向新的表尾</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">出队操作</span><br><span class="line"><span class="comment">//队头元素出队</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">DeQueue</span><span class="params">(LinkQueue &amp;Q, ElemType &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front == Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;                    <span class="comment">//空队</span></span><br><span class="line">    </span><br><span class="line">    LinkNode *p = Q.front-&gt;next;         <span class="comment">//p指针指向即将删除的结点 (头结点所指向的结点)</span></span><br><span class="line">    x = p-&gt;data;</span><br><span class="line">    Q.front-&gt;next = p-&gt;next;             <span class="comment">//修改头结点的next指针</span></span><br><span class="line">    <span class="keyword">if</span>(Q.rear == p)                      <span class="comment">//此次是最后一个结点出队</span></span><br><span class="line">        Q.rear = Q.front;                <span class="comment">//修改rear指针</span></span><br><span class="line">    <span class="built_in">free</span>(p);                             <span class="comment">//释放结点空间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<ul>
<li><p>队列满的条件<br>顺序存储：预分配存储空间<br>链式存储：一般不会队满，除非内存不足</p>
</li>
<li><p>计算链队长度 (遍历链队)<br>设置一个int length 记录链式队列长度</p>
</li>
<li><p>初始化 &amp; 判空</p>
</li>
<li><p>入队操作</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//新元素入队 (表尾进行)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">EnQueue</span><span class="params">(LinkQueue &amp;Q, ElemType x)</span></span>&#123;</span><br><span class="line">    LinkNode *s = (LinkNode *)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(LinkNode)); <span class="comment">//申请一个新结点</span></span><br><span class="line">    s-&gt;data = x;</span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一个元素入队时需要特别处理</span></span><br><span class="line">    <span class="keyword">if</span>(Q.front = <span class="literal">NULL</span>)&#123;            <span class="comment">//在空队列中插入第一个元素</span></span><br><span class="line">        Q.front = s;               <span class="comment">//修改队头队尾指针</span></span><br><span class="line">        Q.rear = s;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        Q.rear-&gt;next = s;           <span class="comment">//新结点插入到rear结点之后</span></span><br><span class="line">        Q.rear = s;                 <span class="comment">//修改rear指针指向新的表尾结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ul>

        <h3 id="3-2-4双端队列"   >
          <a href="#3-2-4双端队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-4双端队列" class="headerlink" title="3.2.4双端队列"></a>3.2.4双端队列</h3>
      <ol>
<li>定义：双端队列是指允许两端都可以进行入队和出队操作的队列</li>
</ol>
<ul>
<li>双端队列允许从两端插入、两端删除的线性表；</li>
<li>如果只使用其中一端的插入、删除操作，则等同于栈 输入受限的双端队列：允许一端插入，两端删除的线性表；</li>
<li>输出受限的双端队列：允许两端插入，一端删除的线性表；</li>
</ul>

        <h3 id="3-2-5循环队列"   >
          <a href="#3-2-5循环队列" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-2-5循环队列" class="headerlink" title="3.2.5循环队列"></a>3.2.5循环队列</h3>
      <p>利用一组地址连续的存储单元依次存放队列中的数据元素。因为队头和队尾的位置是变化的。所以：设头、尾指针。</p>

        <h2 id="3-3栈的应用"   >
          <a href="#3-3栈的应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3栈的应用" class="headerlink" title="3.3栈的应用"></a>3.3栈的应用</h2>
      
        <h3 id="3-3-1栈在括号匹配中的应用"   >
          <a href="#3-3-1栈在括号匹配中的应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-1栈在括号匹配中的应用" class="headerlink" title="3.3.1栈在括号匹配中的应用"></a>3.3.1栈在括号匹配中的应用</h3>
      <p>用栈实现括号匹配</p>
<ul>
<li><p>((())) 最后出现的左括号最先被匹配 (栈的特性—LIFO);</p>
</li>
<li><p>遇到左括号就入栈;</p>
</li>
<li><p>遇到右括号，就“消耗”一个左括号 (出栈);<br>匹配失败情况：</p>
</li>
<li><p>扫描到右括号且栈空，则该右括号单身;</p>
</li>
<li><p>扫描完所有括号后，栈非空，则该左括号单身;</p>
</li>
<li><p>左右括号不匹配;</p>
</li>
</ul>
<p>代码：</p>
<figure class="highlight c++"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10   </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="type">char</span> data[MaxSize];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; SqStack;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化栈</span></span><br><span class="line"><span class="built_in">InitStack</span>(SqStack &amp;S)</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack &amp;S)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//新元素入栈</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S, <span class="type">char</span> x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//栈顶元素出栈，用x返回</span></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S, <span class="type">char</span> &amp;x)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bracketCheck</span><span class="params">(<span class="type">char</span> str[], <span class="type">int</span> length)</span></span>&#123;</span><br><span class="line">    SqStack S;      <span class="comment">//声明</span></span><br><span class="line">    <span class="built_in">InitStack</span>(S);   <span class="comment">//初始化栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(str[i] == <span class="string">&#x27;(&#x27;</span> || str[i] == <span class="string">&#x27;[&#x27;</span> || str[i] == <span class="string">&#x27;&#123;&#x27;</span>)&#123;</span><br><span class="line">            <span class="built_in">Push</span>(S, str[i]);       <span class="comment">//扫描到左括号，入栈</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">StackEmpty</span>(S))      <span class="comment">//扫描到右括号，且当前栈空</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;      <span class="comment">//匹配失败</span></span><br><span class="line">            </span><br><span class="line">            <span class="type">char</span> topElem;          <span class="comment">//存储栈顶元素</span></span><br><span class="line">            <span class="built_in">Pop</span>(S, topElem);       <span class="comment">//栈顶元素出栈</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;(&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;[&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; topElem != <span class="string">&#x27;&#123;&#x27;</span> )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">StackEmpty</span>(S);                <span class="comment">//栈空说明匹配成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="3-3-2栈在表达式求值中的应用"   >
          <a href="#3-3-2栈在表达式求值中的应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-2栈在表达式求值中的应用" class="headerlink" title="3.3.2栈在表达式求值中的应用"></a>3.3.2栈在表达式求值中的应用</h3>
      <ol>
<li>中缀表达式 (需要界限符)<br>运算符在两个操作数中间:</li>
</ol>
<p>① a + b<br>② a + b - c<br>③ a + b - c*d<br>④ ((15 ÷ (7-(1+1)))×3)-(2+(1+1))<br>⑤ A + B × (C - D) - E ÷ F</p>
<ol>
<li>后缀表达式 (逆波兰表达式)<br>运算符在两个操作数后面:</li>
</ol>
<p>① a b +<br>② ab+ c - &#x2F; a bc- +<br>③ ab+ cd* -<br>④ 15 7 1 1 + - ÷ 3 × 2 1 1 + + -<br>⑤ A B C D - × + E F ÷ - (机算结果)<br>  A B C D - × E F ÷ - + (不选择)</p>
<p>中缀表达式转后缀表达式-手算<br>步骤1： 确定中缀表达式中各个运算符的运算顺序</p>
<p>步骤2： 选择下一个运算符，按照[左操作数 右操作数 运算符]的方式组合成一个新的操作数</p>
<p>步骤3： 如果还有运算符没被处理，继续步骤2</p>
<p>“左优先”原则: 只要左边的运算符能先计算，就优先算左边的 (保证运算顺序唯一)；</p>
<p>中缀：A + B - C * D &#x2F; E + F<br>       ①   ④   ②   ③   ⑤<br>后缀：A B + C D * E &#x2F; - F +</p>

        <h3 id="重点：中缀表达式转后缀表达式-机算"   >
          <a href="#重点：中缀表达式转后缀表达式-机算" class="heading-link"><i class="fas fa-link"></i></a><a href="#重点：中缀表达式转后缀表达式-机算" class="headerlink" title="重点：中缀表达式转后缀表达式-机算"></a>重点：中缀表达式转后缀表达式-机算</h3>
      <p>初始化一个栈，用于保存暂时还不能确定运算顺序的运算符。从左到右处理各个元素，直到末尾。可能遇到三种情况:</p>
<p>遇到操作数: 直接加入后缀表达式。<br>遇到界限符: 遇到 ‘(’ 直接入栈; 遇到 ‘)’ 则依次弹出栈内运算符并加入后缀表达式，直到弹出 ‘(’ 为止。注意: ‘(‘ 不加入后缀表达式。<br>遇到运算符: 依次弹出栈中优先级高于或等于当前运算符的所有运算符，并加入后缀表达式，若碰到 ‘(’ 或栈空则停止。之后再把当前运算符入栈。<br>按上述方法处理完所有字符后，将栈中剩余运算符依次弹出，并加入后缀表达式。</p>
<p>后缀表达式的计算—手算:<br>从左往右扫描，每遇到一个运算符，就让运算符前面最近的两个操作数执行对应的运算，合体为一个操作数；</p>
<p>**注意： 两个操作数的左右顺序</p>

        <h3 id="重点：后缀表达式的计算—机算"   >
          <a href="#重点：后缀表达式的计算—机算" class="heading-link"><i class="fas fa-link"></i></a><a href="#重点：后缀表达式的计算—机算" class="headerlink" title="重点：后缀表达式的计算—机算"></a>重点：后缀表达式的计算—机算</h3>
      <p>用栈实现后缀表达式的计算（栈用来存放当前暂时不能确定运算次序的操作数）</p>
<p>步骤1: 从左往后扫描下一个元素，直到处理完所有元素;</p>
<p>步骤2: 若扫描到操作数，则压入栈，并回到步骤1;否则执行步骤3;</p>
<p>步骤3: 若扫描到运算符，则弹出两个栈顶元素，执行相应的运算，运算结果压回栈顶，回到步骤1;</p>
<p>注意: 先出栈的是“右操作数”</p>
<ol start="3">
<li>前缀表达式 (波兰表达式)<br>运算符在两个操作数前面:</li>
</ol>
<p>① + a b<br>② - +ab  c<br>③ - +ab *cd</p>
<p>中缀表达式转前缀表达式—手算<br>步骤1： 确定中缀表达式中各个运算符的运算顺序</p>
<p>步骤2： 选择下一个运算符，按照[运算符 左操作数 右操作数]的方式组合成一个新的操作数</p>
<p>步骤3： 如果还有运算符没被处理，就继续执行步骤2</p>
<p>“右优先”原则: 只要右边的运算符能先计算，就优先算右边的;</p>
<p>中缀：A + B * (C - D) - E &#x2F; F<br>       ⑤   ③    ②    ④   ①<br>前缀：+ A - * B - C D &#x2F; E F<br>1<br>2<br>3<br>前缀表达式的计算—机算<br>用栈实现前缀表达式的计算</p>
<p>步骤1: 从右往左扫描下一个元素，直到处理完所有元素；</p>
<p>步骤2: 若扫描到操作数则压入栈，并回到步骤1，否则执行步骤3</p>
<p>步骤3: 若扫描到运算符，则弹出两个栈顶元素，执行相应运算，运算结果压回栈顶，回到步骤1；</p>
<p>注意: 先出栈的是“左操作数”</p>
<ol start="4">
<li>中缀表达式的计算(用栈实现)<br>两个算法的结合： 中缀转后缀 + 后缀表达式的求值</li>
</ol>
<p>初始化两个栈，操作数栈 和运算符栈</p>
<p>若扫描到操作数，压人操作数栈</p>
<p>若扫描到运算符或界限符，则按照“中缀转后缀”相同的逻辑压入运算符栈 (期间也会弹出运算符，每当弹出一个运算符时，就需要再弹出两个操作数栈的栈项元素并执行相应运算，运算结果再压回操作数栈)</p>

        <h3 id="3-3-3栈在递归中的应用"   >
          <a href="#3-3-3栈在递归中的应用" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-3-3栈在递归中的应用" class="headerlink" title="3.3.3栈在递归中的应用"></a>3.3.3栈在递归中的应用</h3>
      <p>函数调用的特点：最后被调用的函数最先执行结束(LIFO)</p>
<p>函数调用时，需要用一个栈存储：</p>
<ul>
<li>调用返回地址</li>
<li>实参</li>
<li>局部变量<br>递归调用时，函数调用栈称为 “递归工作栈”:</li>
</ul>
<p>每进入一层递归，就将递归调用所需信息压入栈顶；<br>每退出一层递归，就从栈顶弹出相应信息；<br>**缺点：太多层递归可能回导致栈溢出；</p>
<p>适合用“递归”算法解决：可以把原始问题转换为属性相同，但规模较小的问题；</p>

        <h2 id="3-4特殊矩阵的压缩存储"   >
          <a href="#3-4特殊矩阵的压缩存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-4特殊矩阵的压缩存储" class="headerlink" title="3.4特殊矩阵的压缩存储"></a>3.4特殊矩阵的压缩存储</h2>
      <p>矩阵定义： 一个由m*n个元素排成的m行(横向)n列(纵向)的表。<br>矩阵的常规存储：将矩阵描述为一个二维数组。</p>

        <h3 id="3-4-1数组的存储结构"   >
          <a href="#3-4-1数组的存储结构" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-4-1数组的存储结构" class="headerlink" title="3.4.1数组的存储结构"></a>3.4.1数组的存储结构</h3>
      <ol>
<li>一维数组</li>
</ol>
<p>Elemtype a[10];</p>
<p>各数组元素大小相同，物理上连续存放；</p>
<p>起始地址：LOC</p>
<p>数组下标：默认从0开始！</p>
<p>数组元素 a[i] 的存放地址 &#x3D; LOC + i × sizeof(ElemType)</p>
<ol start="2">
<li>二维数组</li>
</ol>
<p>Elemtype b[2][4]; &#x2F;&#x2F;2行4列的二维数组</p>
<p>行优先&#x2F;列优先存储优点：实现随机存储</p>
<p>起始地址：LOC</p>
<p>M行N列的二维数组 b[M][N] 中，b[i][j]的存储地址：</p>
<p>行优先存储: LOC + (i×N + j) × sizeof(ElemType)<br>列优先存储：LOC + (j×M + i) × sizeof(ElemType)</p>

        <h3 id="3-4-2普通矩阵的存储"   >
          <a href="#3-4-2普通矩阵的存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-4-2普通矩阵的存储" class="headerlink" title="3.4.2普通矩阵的存储"></a>3.4.2普通矩阵的存储</h3>
      <p>二维数组存储：</p>
<ul>
<li>描述矩阵元素时，行、列号通常从1开始；</li>
<li>描述数组时，通常下标从 0 开始；
        <h3 id="3-4-3特殊矩阵的存储"   >
          <a href="#3-4-3特殊矩阵的存储" class="heading-link"><i class="fas fa-link"></i></a><a href="#3-4-3特殊矩阵的存储" class="headerlink" title="3.4.3特殊矩阵的存储"></a>3.4.3特殊矩阵的存储</h3>
      特殊矩阵——压缩存储空间（只存有用的数据）</li>
</ul>
<p>矩阵的压缩存储：为多个相同的非零元素只分配一个存储空间；对零元素不分配空间。</p>
<ol>
<li>对称矩阵(方阵)<br>在一个n阶方阵A中，若元素满足下述性值：<br>则称A为对称矩阵。</li>
</ol>
<p>2.三角矩阵(方阵)<br>以主对角线划分，三角矩阵有上（下）三角两种。上（下）三角矩阵的下（上）三角（不含主对角线）中的元素均为常数。在大多数情况下，三角矩阵常数为零。<br>3. 三对角矩阵(方阵)</p>
<p>对角矩阵可按行优先顺序或对角线的顺序，将其压缩存储到一维数组中，且也能找到每个非零元素和向量下标的对应关系。</p>
<ol start="4">
<li>稀疏矩阵<br>设在mn的矩阵中有t个非零元素，令c&#x3D;t&#x2F;(mn),当c&lt;&#x3D;0.05时称为稀疏矩阵。<br>压缩存储原则：存各非零元的值、行列位置和矩阵的行列数。</li>
</ol>
<ul>
<li><p>顺序存储——三元组</p>
</li>
<li><p>链式存储——十字链表法<br>优点：它能够灵活得插入因运算而产生的新的非零元素，删除因运算而产生的新的零元素，实现矩阵的运算。<br>十字链表中结点的结构示意图：</p>
</li>
</ul>
<p>right:用于链接同一行中的下一个非零元素；<br>down:用于链接同一列中的下一个非零元素。</p>
</div><footer class="post-footer"><div class="post-ending ending"><div class="ending__text">------ 本文结束，感谢您的阅读 ------</div></div><div class="post-copyright copyright"><div class="copyright-author"><span class="copyright-author__name">本文作者: </span><span class="copyright-author__value"><a href="http://example.com">小勺</a></span></div><div class="copyright-link"><span class="copyright-link__name">本文链接: </span><span class="copyright-link__value"><a href="http://example.com/2019/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/">http://example.com/2019/05/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</a></span></div><div class="copyright-notice"><span class="copyright-notice__name">版权声明: </span><span class="copyright-notice__value">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" rel="external nofollow" target="_blank">BY-NC-SA</a> 许可协议。转载请注明出处！</span></div></div><div class="post-tags"><span class="post-tags-item"><span class="post-tags-item__icon"><i class="fas fa-tag"></i></span><a class="post-tags-item__link" href="http://example.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></span></div><nav class="post-paginator paginator"><div class="paginator-prev"><a class="paginator-prev__link" href="/2019/05/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E4%B8%B2/"><span class="paginator-prev__icon"><i class="fas fa-angle-left"></i></span><span class="paginator-prev__text">数据结构-串</span></a></div><div class="paginator-next"><a class="paginator-next__link" href="/2019/05/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"><span class="paginator-prev__text">数据结构-线性表</span><span class="paginator-next__icon"><i class="fas fa-angle-right"></i></span></a></div></nav></footer></div></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><div class="sidebar-nav"><span class="sidebar-nav-toc current">文章目录</span><span class="sidebar-nav-ov">站点概览</span></div><section class="sidebar-toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#3-1%E6%A0%88%EF%BC%88stack%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">
          3.1栈（stack）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-1%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">
          3.1.1栈的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%88%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.1.</span> <span class="toc-text">
          1.栈的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.1.2.</span> <span class="toc-text">
          2.栈的基本操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%A0%88%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">
          3.1.2 栈的顺序存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3%E6%A0%88%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">
          3.1.3栈的链式存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">
          3.2队列（Queue）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">
          3.2.1队列的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2%E9%98%9F%E5%88%97%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">
          3.2.2队列的顺序存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3%E9%98%9F%E5%88%97%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">
          3.2.3队列的链式存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">
          3.2.4双端队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-5%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.2.5.</span> <span class="toc-text">
          3.2.5循环队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.</span> <span class="toc-text">
          3.3栈的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">
          3.3.1栈在括号匹配中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2%E6%A0%88%E5%9C%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">
          3.3.2栈在表达式求值中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9A%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F-%E6%9C%BA%E7%AE%97"><span class="toc-number">1.3.3.</span> <span class="toc-text">
          重点：中缀表达式转后缀表达式-机算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%EF%BC%9A%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%AE%A1%E7%AE%97%E2%80%94%E6%9C%BA%E7%AE%97"><span class="toc-number">1.3.4.</span> <span class="toc-text">
          重点：后缀表达式的计算—机算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-3%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.5.</span> <span class="toc-text">
          3.3.3栈在递归中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8E%8B%E7%BC%A9%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.</span> <span class="toc-text">
          3.4特殊矩阵的压缩存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-1%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">
          3.4.1数组的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-2%E6%99%AE%E9%80%9A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">
          3.4.2普通矩阵的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-3%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.4.3.</span> <span class="toc-text">
          3.4.3特殊矩阵的存储</span></a></li></ol></li></ol></li></ol></section><!-- ov = overview--><section class="sidebar-ov hide"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/assets/tx.jpg" alt="avatar"></div><p class="sidebar-ov-author__text">漏勺的加油站</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">29</div><div class="sidebar-ov-state-item__name">归档</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--categories" href="/categories/"><div class="sidebar-ov-state-item__count">13</div><div class="sidebar-ov-state-item__name">分类</div></a><a class="sidebar-ov-state-item sidebar-ov-state-item--tags" href="/tags/"><div class="sidebar-ov-state-item__count">9</div><div class="sidebar-ov-state-item__name">标签</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="知识共享许可协议" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section><div class="sidebar-reading"><div class="sidebar-reading-info"><span class="sidebar-reading-info__text">你已阅读了 </span><span class="sidebar-reading-info__num">0</span><span class="sidebar-reading-info__perc">%</span></div><div class="sidebar-reading-line"></div></div></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2023</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>小勺</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.8.0"></script><script src="/js/stun-boot.js?v=2.8.0"></script><script src="/js/scroll.js?v=2.8.0"></script><script src="/js/header.js?v=2.8.0"></script><script src="/js/sidebar.js?v=2.8.0"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"live2d-widget-model-miku"},"display":{"position":"left","width":150,"height":190,"hOffset":50,"vOffset":-5},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.8},"log":false});</script></body></html>